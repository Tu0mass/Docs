<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plinko & Mines - Stake Clone</title>
    <style>
        :root {
            --bg-dark: #0f1923;
            --bg-panel: #1a242d;
            --bg-hover: #242f3e;
            --accent: #00e701;
            --accent-hover: #1fff20;
            --text-main: #ffffff;
            --text-dim: #b1b7c2;
            --danger: #ff4d4d;
            --gem: #00e701;
        }

        * { box-sizing: border-box; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        
        body {
            background-color: var(--bg-dark);
            color: var(--text-main);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* Header */
        header {
            height: 60px;
            background-color: var(--bg-panel);
            display: flex;
            align-items: center;
            padding: 0 20px;
            border-bottom: 1px solid #2f3a45;
            justify-content: space-between;
        }

        .logo { font-weight: 900; font-style: italic; font-size: 24px; letter-spacing: 1px; }
        
        .balance-container {
            background: #0b1217;
            padding: 8px 20px;
            border-radius: 4px;
            border: 1px solid #2f3a45;
            font-weight: bold;
            color: var(--accent);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        /* Navigation Tabs */
        .nav-tabs {
            display: flex;
            background: var(--bg-panel);
            padding: 10px 20px 0 20px;
            gap: 10px;
        }

        .tab-btn {
            background: transparent;
            border: none;
            color: var(--text-dim);
            padding: 10px 20px;
            cursor: pointer;
            font-weight: 600;
            border-bottom: 3px solid transparent;
            transition: 0.2s;
        }

        .tab-btn:hover { color: #fff; }
        .tab-btn.active { color: #fff; border-bottom: 3px solid var(--accent); }

        /* Main Layout */
        .main-container {
            display: flex;
            flex: 1;
            height: calc(100vh - 110px);
        }

        /* Sidebar Controls */
        .controls {
            width: 300px;
            background-color: var(--bg-panel);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border-right: 1px solid #2f3a45;
        }

        .input-group { display: flex; flex-direction: column; gap: 5px; }
        .input-group label { font-size: 12px; color: var(--text-dim); font-weight: 600; }
        
        .input-wrapper {
            display: flex;
            background: #0b1217;
            border: 1px solid #2f3a45;
            border-radius: 4px;
            padding: 2px;
        }
        
        .input-wrapper input {
            background: transparent;
            border: none;
            color: white;
            padding: 10px;
            width: 100%;
            font-weight: bold;
            outline: none;
        }

        .btn-half { 
            background: var(--bg-hover); 
            border: none; 
            color: var(--text-dim); 
            width: 40px; 
            cursor: pointer; 
            font-weight: bold;
        }
        .btn-half:hover { background: #323e4f; }

        .action-btn {
            background-color: var(--accent);
            color: #000;
            border: none;
            padding: 15px;
            border-radius: 4px;
            font-weight: 700;
            font-size: 16px;
            cursor: pointer;
            margin-top: 10px;
            transition: 0.2s;
        }

        .action-btn:hover { background-color: var(--accent-hover); transform: translateY(-1px); }
        .action-btn:active { transform: translateY(1px); }
        .action-btn:disabled { background-color: #35404b; color: #666; cursor: not-allowed; transform: none; }

        select {
            background: #0b1217;
            color: white;
            border: 1px solid #2f3a45;
            padding: 10px;
            border-radius: 4px;
            width: 100%;
            outline: none;
        }

        /* Game Area */
        .game-stage {
            flex: 1;
            background-color: var(--bg-dark);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }

        /* --- MINES CSS --- */
        .mines-container {
            display: none;
            width: 100%;
            height: 100%;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .mines-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            width: 400px;
            height: 400px;
        }

        .mine-tile {
            background-color: #2f3a45;
            border-radius: 5px;
            cursor: pointer;
            transition: 0.2s;
            border-bottom: 4px solid #1a2228;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            position: relative;
        }

        .mine-tile:hover { background-color: #3a4755; transform: translateY(-2px); }
        .mine-tile:active { transform: translateY(0); border-bottom-width: 2px; }
        
        .mine-tile.revealed { cursor: default; transform: none; border-bottom: none; }
        .mine-tile.gem { background-color: #0f1923; border: 2px solid var(--gem); }
        .mine-tile.bomb { background-color: #0f1923; border: 2px solid var(--danger); opacity: 1; }
        .mine-tile.dim { opacity: 0.4; }

        .mines-info {
            margin-bottom: 20px;
            text-align: center;
            height: 30px;
        }

        /* --- PLINKO CSS --- */
        .plinko-container {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
            padding-top: 20px;
        }
        
        canvas { display: block; }

        .plinko-stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
        }

        /* Utilities */
        .hidden { display: none !important; }
        .visible { display: flex !important; }

        /* Jewel/Bomb SVG Replacements */
        .icon { width: 60%; height: 60%; }
    </style>
</head>
<body>

    <header>
        <div class="logo">STAKE<span style="color:var(--accent)">.CLONE</span></div>
        <div class="balance-container">
            $<span id="balance">1000.00</span>
        </div>
    </header>

    <div class="nav-tabs">
        <button class="tab-btn active" onclick="switchGame('plinko')">Plinko</button>
        <button class="tab-btn" onclick="switchGame('mines')">Mines</button>
    </div>

    <div class="main-container">
        <!-- CONTROLS SIDEBAR -->
        <div class="controls">
            <div class="input-group">
                <label>Bet Amount</label>
                <div class="input-wrapper">
                    <input type="number" id="betAmount" value="10.00" min="0.01">
                    <button class="btn-half" onclick="halfBet()">Â½</button>
                    <button class="btn-half" onclick="doubleBet()">2x</button>
                </div>
            </div>

            <!-- MINES CONTROLS -->
            <div id="controls-mines" class="hidden">
                <div class="input-group">
                    <label>Mines</label>
                    <select id="minesCount">
                        <option value="1">1</option>
                        <option value="3" selected>3</option>
                        <option value="5">5</option>
                        <option value="10">10</option>
                        <option value="24">24</option>
                    </select>
                </div>
                <button id="btn-mines-play" class="action-btn" onclick="startMines()">Bet</button>
                <button id="btn-mines-cashout" class="action-btn" style="display:none; background-color: #1a242d; border: 1px solid var(--accent); color: var(--accent);" onclick="cashoutMines()">Cashout</button>
            </div>

            <!-- PLINKO CONTROLS -->
            <div id="controls-plinko" class="visible">
                <div class="input-group">
                    <label>Risk</label>
                    <select id="plinkoRisk" onchange="updatePlinkoMultipliers()">
                        <option value="low">Low</option>
                        <option value="medium" selected>Medium</option>
                        <option value="high">High</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>Rows (8-16)</label>
                    <select id="plinkoRows" onchange="initPlinkoBoard()">
                        <option value="8">8 Rows</option>
                        <option value="10">10 Rows</option>
                        <option value="12">12 Rows</option>
                        <option value="14">14 Rows</option>
                        <option value="16" selected>16 Rows</option>
                    </select>
                </div>
                <button id="btn-plinko-play" class="action-btn" onclick="dropBall()">Bet</button>
            </div>
        </div>

        <!-- GAME STAGE -->
        <div class="game-stage">
            
            <!-- PLINKO GAME -->
            <div id="game-plinko" class="plinko-container visible">
                <canvas id="plinkoCanvas"></canvas>
            </div>

            <!-- MINES GAME -->
            <div id="game-mines" class="mines-container">
                <div class="mines-info">
                    <span id="mines-next-mult" style="color: var(--accent); font-weight:bold; font-size: 18px;"></span>
                </div>
                <div class="mines-grid" id="minesGrid">
                    <!-- Generated by JS -->
                </div>
            </div>

        </div>
    </div>

    <script>
        /* --- GLOBAL STATE --- */
        let balance = 1000.00;
        let currentGame = 'plinko';
        
        const domBalance = document.getElementById('balance');
        const domBet = document.getElementById('betAmount');

        function updateBalance(amount) {
            balance += amount;
            domBalance.textContent = balance.toFixed(2);
        }

        function halfBet() { domBet.value = (parseFloat(domBet.value) / 2).toFixed(2); }
        function doubleBet() { domBet.value = (parseFloat(domBet.value) * 2).toFixed(2); }

        function switchGame(game) {
            currentGame = game;
            
            // UI Toggles
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');

            if(game === 'plinko') {
                document.getElementById('controls-plinko').classList.remove('hidden');
                document.getElementById('controls-plinko').classList.add('visible');
                document.getElementById('controls-mines').classList.remove('visible');
                document.getElementById('controls-mines').classList.add('hidden');

                document.getElementById('game-plinko').classList.add('visible');
                document.getElementById('game-mines').classList.remove('visible', 'hidden');
                document.getElementById('game-mines').style.display = 'none';
                
                // Resume Canvas
                if(!animationId) animatePlinko();
            } else {
                document.getElementById('controls-mines').classList.remove('hidden');
                document.getElementById('controls-mines').classList.add('visible');
                document.getElementById('controls-plinko').classList.remove('visible');
                document.getElementById('controls-plinko').classList.add('hidden');

                document.getElementById('game-mines').style.display = 'flex';
                document.getElementById('game-plinko').classList.remove('visible');
                
                // Reset mines info if not playing
                if(!minesActive) {
                    initMinesGrid();
                }
            }
        }

        /* --- MINES LOGIC --- */
        let minesGrid = []; // 0 = gem, 1 = mine
        let revealedCount = 0;
        let minesCount = 3;
        let minesActive = false;
        let currentMultiplier = 1.0;
        let minesBet = 0;

        const domMinesGrid = document.getElementById('minesGrid');
        const btnMinesPlay = document.getElementById('btn-mines-play');
        const btnMinesCashout = document.getElementById('btn-mines-cashout');
        const txtMinesMult = document.getElementById('mines-next-mult');

        function initMinesGrid() {
            domMinesGrid.innerHTML = '';
            for(let i=0; i<25; i++) {
                let tile = document.createElement('div');
                tile.className = 'mine-tile';
                tile.dataset.index = i;
                tile.onclick = () => clickTile(i);
                domMinesGrid.appendChild(tile);
            }
            txtMinesMult.innerHTML = '';
        }

        function startMines() {
            const bet = parseFloat(domBet.value);
            if(bet > balance) return alert("Insufficient funds");
            if(bet <= 0) return alert("Invalid bet");

            updateBalance(-bet);
            minesBet = bet;
            minesActive = true;
            minesCount = parseInt(document.getElementById('minesCount').value);
            revealedCount = 0;
            currentMultiplier = 1.0;

            // Setup UI
            btnMinesPlay.style.display = 'none';
            btnMinesCashout.style.display = 'block';
            document.querySelectorAll('.mine-tile').forEach(t => {
                t.className = 'mine-tile'; // reset
                t.innerHTML = '';
            });

            // Generate Mines
            minesGrid = Array(25).fill(0);
            let placed = 0;
            while(placed < minesCount) {
                let idx = Math.floor(Math.random() * 25);
                if(minesGrid[idx] === 0) {
                    minesGrid[idx] = 1;
                    placed++;
                }
            }

            calculateNextMultiplier();
        }

        function calculateMinesMultiplier() {
            // Standard formula for Mines multiplier
            // n! / (n-k)! where n is tiles left, k is tiles chosen... simplified:
            // Total tiles / (Total - Mines) ... iteratively
            
            let mult = 1.0;
            // This is a simplified probability accumulation
            // A simpler way that Stake does: 
            // Multiplier for next pick = current_mult * (remaining_tiles / remaining_safe_tiles)
            
            // Let's just use the next hit calculation
            let tilesRemaining = 25 - revealedCount;
            let safeRemaining = 25 - minesCount - revealedCount;
            
            // Probability of hitting a gem
            let prob = safeRemaining / tilesRemaining;
            // House edge is built into the inverse, but we'll just do raw fair probability for "fake" balance
            let nextMultStep = 0.99 / prob; // 0.99 represents 1% house edge
            
            return nextMultStep; 
        }
        
        // Pre-calculate full table or compute on fly. Let's compute current total multiplier.
        function getAccumulatedMultiplier() {
            let m = 1.0;
            for(let i=0; i<revealedCount; i++) {
                let total = 25 - i;
                let safe = 25 - minesCount - i;
                m *= (total / safe);
            }
            return m * 0.99; // House edge
        }

        function calculateNextMultiplier() {
            let nextTiles = revealedCount + 1;
            let m = 1.0;
            for(let i=0; i<nextTiles; i++) {
                let total = 25 - i;
                let safe = 25 - minesCount - i;
                m *= (total / safe);
            }
            m = m * 0.99;
            
            let curr = getAccumulatedMultiplier();
            if(revealedCount === 0) curr = 1.0;

            btnMinesCashout.innerHTML = `Cashout $${(minesBet * curr).toFixed(2)} <span style="font-size:12px;color:#aaa">(${curr.toFixed(2)}x)</span>`;
            txtMinesMult.innerText = `Next: ${m.toFixed(2)}x`;
        }

        function clickTile(index) {
            if(!minesActive) return;
            const tile = domMinesGrid.children[index];
            if(tile.classList.contains('revealed')) return;

            tile.classList.add('revealed');

            if(minesGrid[index] === 1) {
                // BOOM
                tile.classList.add('bomb');
                tile.innerHTML = 'ðŸ’£';
                gameOverMines(false);
            } else {
                // GEM
                tile.classList.add('gem');
                tile.innerHTML = 'ðŸ’Ž';
                revealedCount++;
                
                if(revealedCount === (25 - minesCount)) {
                    // All gems found
                    cashoutMines();
                } else {
                    calculateNextMultiplier();
                }
            }
        }

        function cashoutMines() {
            if(!minesActive) return;
            minesActive = false;
            
            let finalMult = getAccumulatedMultiplier();
            if(revealedCount === 0) finalMult = 0; // Refund? No, usually can't cashout 0. But let's assume min 1 move.
            
            let winAmt = minesBet * finalMult;
            updateBalance(winAmt);
            
            gameOverMines(true);
        }

        function gameOverMines(win) {
            minesActive = false;
            btnMinesPlay.style.display = 'block';
            btnMinesCashout.style.display = 'none';
            txtMinesMult.innerHTML = win ? "<span style='color:#00e701'>WIN!</span>" : "<span style='color:#ff4d4d'>BUST!</span>";

            // Reveal all
            minesGrid.forEach((isMine, idx) => {
                const t = domMinesGrid.children[idx];
                if(!t.classList.contains('revealed')) {
                    t.classList.add('dim');
                    if(isMine) {
                        t.innerHTML = 'ðŸ’£';
                        t.style.border = '1px solid #ff4d4d';
                    } else {
                        t.innerHTML = 'ðŸ’Ž';
                    }
                }
            });
        }

        initMinesGrid();


        /* --- PLINKO LOGIC (Canvas) --- */
        const canvas = document.getElementById('plinkoCanvas');
        const ctx = canvas.getContext('2d');

        // Configuration
        let pRows = 16;
        let pRisk = 'medium';
        const pPegSize = 3;
        const pBallSize = 5;
        let width, height;
        
        // State
        let particles = []; // The falling balls
        let pegs = [];
        let buckets = []; // The multipliers at bottom
        let animationId;

        // Multipliers Data (Simplified Stake clones)
        const multipliers = {
            low: {
                8: [5.6, 2.1, 1.1, 1, 0.5, 1, 1.1, 2.1, 5.6],
                16: [16, 9, 2, 1.4, 1.4, 1.2, 1.1, 1, 0.5, 1, 1.1, 1.2, 1.4, 1.4, 2, 9, 16]
            },
            medium: {
                8: [13, 3, 1.3, 0.7, 0.4, 0.7, 1.3, 3, 13],
                16: [110, 41, 10, 5, 3, 1.5, 1, 0.5, 0.3, 0.5, 1, 1.5, 3, 5, 10, 41, 110]
            },
            high: {
                8: [29, 4, 1.5, 0.3, 0.2, 0.3, 1.5, 4, 29],
                16: [1000, 130, 26, 9, 4, 2, 0.2, 0.2, 0.2, 0.2, 0.2, 2, 4, 9, 26, 130, 1000]
            }
        };

        // Fallback generation for rows 10, 12, 14 just to keep code shorter
        // We will dynamically interpolate logic or just stick to 8/16 for this demo
        // NOTE: For this Single File Demo, I will strictly enforce 16 rows logic visually 
        // but allow select to change scale. Actually, let's just support 16 rows fully 
        // and scale the buckets for others or just regenerate geometry.
        
        function getMultipliers() {
            // If data exists, use it, otherwise generate fake curve
            if(multipliers[pRisk][pRows]) return multipliers[pRisk][pRows];
            
            // Procedural generation for 10, 12, 14 to save space
            let count = pRows + 1;
            let arr = [];
            let center = Math.floor(count/2);
            for(let i=0; i<count; i++) {
                let dist = Math.abs(i - center);
                let val = 0.2 + (dist * dist * (pRisk === 'high' ? 0.5 : 0.2));
                arr.push(parseFloat(val.toFixed(1)));
            }
            return arr;
        }

        function resizeCanvas() {
            width = document.getElementById('game-plinko').offsetWidth;
            height = 600; // Fixed height for simplicity
            canvas.width = width;
            canvas.height = height;
            initPlinkoBoard();
        }
        window.addEventListener('resize', resizeCanvas);

        function initPlinkoBoard() {
            pRows = parseInt(document.getElementById('plinkoRows').value);
            pegs = [];
            buckets = [];
            
            const padding = 50;
            const availableWidth = width - (padding*2);
            const spacing = availableWidth / (pRows + 2); // Adjust spacing based on rows
            
            // 1. Create Pegs (Pyramid)
            // Row 0 has 3 pegs? No, Row 0 is the spawn. 
            // Row 1 has 3 pegs, Row 2 has 4... 
            // Standard Plinko: Row i has i+3 pegs usually.
            // Let's simplify: Row 0 has 3 pegs.
            
            const startY = 50;
            
            for(let r = 0; r < pRows; r++) {
                for(let c = 0; c <= r + 2; c++) {
                    // Center the row
                    const rowWidth = (r + 2) * spacing;
                    const offsetX = (width - rowWidth) / 2;
                    const x = offsetX + c * spacing;
                    const y = startY + r * spacing; // equal vertical spacing
                    pegs.push({x, y});
                }
            }

            // 2. Create Buckets
            const mults = getMultipliers();
            const lastRowY = startY + (pRows) * spacing;
            
            // Buckets sit between the last row of pegs
            // Last row has pRows + 2 pegs. There are pRows + 1 gaps.
            const rowWidth = (pRows + 2) * spacing;
            const offsetX = (width - rowWidth) / 2;
            
            for(let i = 0; i < mults.length; i++) {
                let x = offsetX + (i * spacing) + (spacing * 0.5) + (spacing); // Math to align with gaps
                // Simplify: just under the pegs
                // Last pegs are at r = pRows-1.
                // We want buckets at r = pRows.
                
                let bx = offsetX + (i * spacing) + (spacing/2) + spacing; 
                // Correction: The first peg of last row is at offsetX.
                // The gaps are between pegs.
                // Visual alignment is tricky without a physics engine, but we will rig the path.
                
                buckets.push({
                    x: bx,
                    y: lastRowY + 20,
                    val: mults[i],
                    width: spacing - 4,
                    height: 30,
                    color: getBucketColor(mults[i])
                });
            }
        }

        function getBucketColor(val) {
            if(val < 1) return '#1a242d'; // Loss
            if(val < 3) return '#334354';
            if(val < 10) return '#00e701';
            return '#ffa500'; // Gold for high win
        }

        function updatePlinkoMultipliers() {
            pRisk = document.getElementById('plinkoRisk').value;
            initPlinkoBoard();
        }

        // Animation Loop
        function animatePlinko() {
            ctx.clearRect(0, 0, width, height);
            
            // Draw Pegs
            ctx.fillStyle = 'white';
            for(let p of pegs) {
                ctx.beginPath();
                ctx.arc(p.x, p.y, pPegSize, 0, Math.PI*2);
                ctx.fill();
            }

            // Draw Buckets
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.font = "bold 10px Arial";
            
            for(let b of buckets) {
                // Bucket Box
                ctx.fillStyle = b.color;
                
                // Interaction glow
                if(b.active > 0) {
                    ctx.fillStyle = "white";
                    b.active--;
                    // Move bucket down slightly for bounce effect
                    ctx.fillRect(b.x - b.width/2, b.y + 2, b.width, b.height);
                } else {
                    ctx.fillRect(b.x - b.width/2, b.y, b.width, b.height);
                }

                // Text
                ctx.fillStyle = b.val < 1 ? '#aaa' : '#000';
                ctx.fillText(b.val + "x", b.x, b.y + 15);
            }

            // Draw/Update Particles
            for(let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                
                // Move particle towards target
                let target = p.path[p.pathIndex];
                
                // Simple lerp for smoothness
                let dx = target.x - p.x;
                let dy = target.y - p.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                
                if(dist < 5) {
                    // Reached node
                    p.pathIndex++;
                    if(p.pathIndex >= p.path.length) {
                        // Finished
                        finishParticle(p);
                        particles.splice(i, 1);
                        continue;
                    }
                } else {
                    // Move
                    p.x += (dx / dist) * 8; // Speed
                    p.y += (dy / dist) * 8;
                }

                ctx.beginPath();
                ctx.fillStyle = '#ffed00';
                ctx.arc(p.x, p.y, pBallSize, 0, Math.PI*2);
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#ffed00';
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            animationId = requestAnimationFrame(animatePlinko);
        }

        function dropBall() {
            const bet = parseFloat(domBet.value);
            if(bet > balance) return alert("Insufficient funds");
            updateBalance(-bet);

            // Generate a path
            // The logic: The ball hits a peg, and chooses Left (-0.5 spacing) or Right (+0.5 spacing)
            // We simulate the decision tree to find the landing bucket.
            
            const spacing = (width - 100) / (pRows + 2); // Approx spacing used in init
            let path = [];
            
            // Start pos (Top middle)
            let currIndex = 0; // index in the row logic. 0 is center? 
            // Let's map it to the buckets array index.
            // Buckets count = pRows + 1.
            // Plinko distribution approximates Normal Distribution.
            // We simulate L/R coin flips.
            
            let bucketIndex = 0; 
            let moves = []; // 0 for left, 1 for right
            
            for(let r=0; r<pRows; r++) {
                let dir = Math.random() > 0.5 ? 1 : 0;
                moves.push(dir);
                bucketIndex += dir;
            }
            
            // Now build the visual path
            // We need to find the coordinates of the pegs it hits.
            // My Peg generation logic:
            // r=0 has 3 pegs. c=0,1,2.
            // Spawn is between c=0 and c=1 usually...
            
            // Simplified Visual Path:
            // Start at top center
            let startX = width/2;
            let startY = 20;
            path.push({x: startX, y: startY});

            let currentX = startX;
            let currentY = 50; // Peg Row 0 Y
            
            // Calculate precise spacing again to match drawing
            const availableWidth = width - (100);
            const stepX = availableWidth / (pRows + 2);
            
            // Adjust Start to be aligned with the single top gap
            // Logic: The ball falls through the gaps, bouncing off pegs.
            // Coordinate system: 
            // Row 0 Pegs Y = 50. Ball hits peg at 50? No, ball passes peg.
            // Let's just interpolate positions based on the 'bucketIndex' outcome.
            
            // Rigged visual path
            for(let i=0; i<=pRows; i++) {
                // Interpolate X based on how many 'Rights' we took so far
                let rightCount = moves.slice(0, i).reduce((a,b)=>a+b, 0);
                
                // Row width grows
                // Center of row
                let y = 50 + i * stepX;
                
                // Calculate Deviation from center
                // Max deviation at row i is +/- i * 0.5 * stepX
                // Actually, let's just target the final bucket and jiggle slightly
                // This is the "Lazy" single-file physics implementation
                
                // Better Implementation: Calculate exact peg locations
                // At row i, the ball is at:
                // X = Center + (rightCount - (i/2)) * stepX
                
                let deviation = rightCount - (i/2.0);
                let x = (width/2) + (deviation * stepX);
                
                // Add randomness to hit the peg "glance"
                if(i < pRows) {
                   path.push({x: x, y: y});
                } else {
                   // Final Bucket position
                   // Map bucketIndex to bucket array
                   // bucketIndex ranges from 0 to pRows.
                   let b = buckets[bucketIndex];
                   path.push({x: b.x, y: b.y - 15});
                }
            }

            particles.push({
                x: startX,
                y: startY,
                path: path,
                pathIndex: 0,
                bet: bet,
                finalBucketIdx: bucketIndex
            });
        }

        function finishParticle(p) {
            const b = buckets[p.finalBucketIdx];
            b.active = 5; // triggers animation
            
            const win = p.bet * b.val;
            updateBalance(win);
            
            // Add floating text (optional, simplified here)
            // console.log(`Won ${win}`);
        }

        // Initialize
        resizeCanvas();
        initMinesGrid();
        animatePlinko();

    </script>
</body>
</html>