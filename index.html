<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Bandit's Heist - Cluster Slot</title>
    <style>
        :root {
            --bg-color: #1a1510;
            --cabinet-color: #2e241b;
            --reel-bg: #3d3226;
            --gold-color: #ffcc00;
            --ui-bg: #111;
            --accent: #e76f51;
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            background: var(--cabinet-color);
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Header & Bonus Indicator */
        header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        h1 { margin: 0; font-size: 1.5rem; color: var(--gold-color); text-transform: uppercase; text-shadow: 0 2px 0 #000; }
        
        #bonus-banner {
            background: linear-gradient(45deg, #e76f51, #d62828);
            padding: 5px 15px;
            border-radius: 5px;
            font-weight: bold;
            display: none;
            animation: pulse 1s infinite;
        }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* Grid Area */
        #grid-wrapper {
            position: relative;
            background: var(--reel-bg);
            border: 4px solid #111;
            border-radius: 8px;
            padding: 5px;
            margin-bottom: 15px;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(6, 60px);
            grid-template-rows: repeat(5, 60px);
            gap: 4px;
        }

        .cell {
            width: 60px;
            height: 60px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        /* Golden Square Logic */
        .cell.golden::after {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            border: 2px solid var(--gold-color);
            background: rgba(255, 215, 0, 0.15);
            box-shadow: inset 0 0 10px var(--gold-color);
            z-index: 0;
            box-sizing: border-box;
            animation: glow 2s infinite alternate;
        }

        @keyframes glow { from { box-shadow: inset 0 0 5px var(--gold-color); } to { box-shadow: inset 0 0 15px var(--gold-color); } }

        /* Symbols */
        .symbol {
            width: 90%;
            height: 90%;
            z-index: 1;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.2s;
        }

        .symbol.falling { animation: dropIn 0.4s ease-out; }
        .symbol.removed { transform: scale(0); opacity: 0; }
        .symbol.win-anim { animation: winPop 0.3s ease-in-out 2; }

        @keyframes dropIn { 0% { transform: translateY(-100px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } }
        @keyframes winPop { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }

        /* Coin Value Overlay */
        .coin-val {
            position: absolute;
            font-size: 10px;
            font-weight: bold;
            color: #000;
            z-index: 2;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        /* UI Controls */
        #ui-panel {
            width: 100%;
            background: var(--ui-bg);
            padding: 15px;
            border-radius: 8px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            border-top: 2px solid #444;
        }

        .stat-box {
            display: flex;
            flex-direction: column;
        }
        .label { font-size: 0.7rem; color: #888; text-transform: uppercase; }
        .value { font-size: 1.1rem; font-weight: bold; font-family: monospace; color: #fff; }
        .win-value { color: #4cd137; }

        .controls {
            grid-column: 1 / -1;
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        button {
            border: none;
            border-radius: 5px;
            padding: 12px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            transition: filter 0.2s;
        }
        button:hover { filter: brightness(1.1); }
        button:active { transform: translateY(2px); }
        button:disabled { filter: grayscale(1); cursor: not-allowed; }

        #spin-btn { flex: 2; background: #4cd137; color: #000; font-size: 1.1rem; }
        #buy-bonus-btn { flex: 1; background: var(--accent); color: #fff; font-size: 0.9rem; display: flex; flex-direction: column; align-items: center; line-height: 1; }
        #buy-bonus-btn span { font-size: 0.6rem; margin-top: 3px; opacity: 0.8; }

        .bet-control {
            display: flex;
            align-items: center;
            background: #333;
            border-radius: 5px;
            padding: 0 5px;
        }
        .bet-btn { background: none; color: white; padding: 5px 10px; font-size: 1.2rem; }
        #bet-amount { margin: 0 10px; font-family: monospace; width: 40px; text-align: center; }

        /* Overlay Message */
        #message-overlay {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 20px 40px;
            border: 2px solid var(--gold-color);
            border-radius: 10px;
            text-align: center;
            z-index: 100;
            display: none;
            pointer-events: none;
        }
        #message-overlay h2 { color: var(--gold-color); margin: 0; font-size: 2rem; }
        #message-overlay p { font-size: 1.2rem; margin: 5px 0 0 0; }

    </style>
</head>
<body>

    <div id="game-container">
        <header>
            <h1>Bandit's Alley</h1>
            <div id="bonus-banner">FREE SPINS ACTIVE (<span id="fs-count">0</span>)</div>
        </header>

        <div id="grid-wrapper">
            <div id="grid">
                <!-- Cells generated by JS -->
            </div>
            <div id="message-overlay">
                <h2 id="msg-title">BIG WIN</h2>
                <p id="msg-val">1000</p>
            </div>
        </div>

        <div id="ui-panel">
            <div class="stat-box">
                <span class="label">Balance</span>
                <span class="value" id="balance-display">1000.00</span>
            </div>
            <div class="stat-box" style="align-items: flex-end;">
                <span class="label">Total Win</span>
                <span class="value win-value" id="win-display">0.00</span>
            </div>

            <div class="controls">
                <div class="bet-control">
                    <button class="bet-btn" onclick="changeBet(-1)">-</button>
                    <span id="bet-amount">1</span>
                    <button class="bet-btn" onclick="changeBet(1)">+</button>
                </div>
                <button id="spin-btn" onclick="spin()">Spin</button>
                <button id="buy-bonus-btn" onclick="buyBonus()">
                    Buy Bonus
                    <span>100x Bet</span>
                </button>
            </div>
        </div>
    </div>

<script>
/** 
 * CONFIGURATION & STATE 
 */
const CONFIG = {
    rows: 5,
    cols: 6,
    minCluster: 5, // Minimum symbols to connect
    animSpeed: 400,
    paytable: {
        '10': 0.1, 'J': 0.1, 'Q': 0.2, 'K': 0.3, 'A': 0.5,
        'cheese': 1.0, 'beer': 1.5, 'baguette': 2.0, 'hat': 5.0
    },
    symbols: ['10', 'J', 'Q', 'K', 'A', 'cheese', 'beer', 'baguette', 'hat'],
    weights: [15, 15, 12, 12, 10, 8, 6, 5, 3], // Probabilities corresponding to symbols
    specialWeights: {
        'fs': 0.02, // Chance to drop per cell fill
        'rainbow': 0.015 
    }
};

let state = {
    grid: [], // 2D array of symbol strings
    goldenGrid: [], // 2D boolean array
    balance: 1000,
    bet: 1,
    currentWin: 0,
    isSpinning: false,
    bonusActive: false,
    freeSpins: 0,
    fsTriggersInRound: 0 // Track FS symbols landing
};

// DOM Elements
const gridEl = document.getElementById('grid');
const balEl = document.getElementById('balance-display');
const winEl = document.getElementById('win-display');
const betEl = document.getElementById('bet-amount');
const spinBtn = document.getElementById('spin-btn');
const buyBtn = document.getElementById('buy-bonus-btn');
const bonusBanner = document.getElementById('bonus-banner');
const fsCountEl = document.getElementById('fs-count');
const msgOverlay = document.getElementById('message-overlay');
const msgTitle = document.getElementById('msg-title');
const msgVal = document.getElementById('msg-val');

/**
 * SVG GENERATOR
 * Creates inline SVG strings for all symbols.
 */
const SVGS = {
    '10': `<svg viewBox="0 0 100 100"><text x="50" y="70" font-size="60" fill="#a8dadc" text-anchor="middle" font-weight="bold" stroke="black" stroke-width="2">10</text></svg>`,
    'J': `<svg viewBox="0 0 100 100"><text x="50" y="70" font-size="60" fill="#457b9d" text-anchor="middle" font-weight="bold" stroke="black" stroke-width="2">J</text></svg>`,
    'Q': `<svg viewBox="0 0 100 100"><text x="50" y="70" font-size="60" fill="#1d3557" text-anchor="middle" font-weight="bold" stroke="black" stroke-width="2">Q</text></svg>`,
    'K': `<svg viewBox="0 0 100 100"><text x="50" y="70" font-size="60" fill="#e63946" text-anchor="middle" font-weight="bold" stroke="black" stroke-width="2">K</text></svg>`,
    'A': `<svg viewBox="0 0 100 100"><text x="50" y="70" font-size="60" fill="#f1faee" text-anchor="middle" font-weight="bold" stroke="black" stroke-width="2">A</text></svg>`,
    
    'cheese': `<svg viewBox="0 0 100 100"><path d="M10,80 L90,80 L90,50 L50,20 L10,50 Z" fill="#f9c74f" stroke="black" stroke-width="3"/><circle cx="30" cy="60" r="5" fill="#f9844a"/><circle cx="60" cy="50" r="8" fill="#f9844a"/><circle cx="70" cy="70" r="4" fill="#f9844a"/></svg>`,
    
    'beer': `<svg viewBox="0 0 100 100"><path d="M25,30 L25,80 Q25,90 35,90 L65,90 Q75,90 75,80 L75,30 Z" fill="#f4a261" stroke="black" stroke-width="3"/><rect x="75" y="40" width="10" height="30" rx="5" fill="none" stroke="black" stroke-width="3"/><path d="M20,30 Q25,10 40,25 Q50,10 60,25 Q75,10 80,30 Z" fill="white" stroke="black" stroke-width="2"/></svg>`,
    
    'baguette': `<svg viewBox="0 0 100 100"><ellipse cx="50" cy="50" rx="40" ry="15" transform="rotate(-30 50 50)" fill="#e09f3e" stroke="black" stroke-width="3"/><path d="M35,45 L45,35 M50,55 L60,45" stroke="#6f4518" stroke-width="3"/></svg>`,
    
    'hat': `<svg viewBox="0 0 100 100"><rect x="25" y="40" width="50" height="40" fill="#222" stroke="white" stroke-width="2"/><rect x="10" y="80" width="80" height="10" rx="2" fill="#222" stroke="white" stroke-width="2"/><rect x="25" y="70" width="50" height="5" fill="#e63946"/></svg>`,
    
    'fs': `<svg viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="#2a9d8f" stroke="white" stroke-width="3"/><text x="50" y="65" font-size="35" fill="white" text-anchor="middle" font-weight="bold">FS</text></svg>`,
    
    'rainbow': `<svg viewBox="0 0 100 100"><path d="M10,80 A40,40 0 0,1 90,80" fill="none" stroke="#e63946" stroke-width="5"/><path d="M15,80 A35,35 0 0,1 85,80" fill="none" stroke="#f4a261" stroke-width="5"/><path d="M20,80 A30,30 0 0,1 80,80" fill="none" stroke="#e9c46a" stroke-width="5"/><path d="M25,80 A25,25 0 0,1 75,80" fill="none" stroke="#2a9d8f" stroke-width="5"/><text x="50" y="95" font-size="14" text-anchor="middle" fill="white">RAINBOW</text></svg>`,

    // Coin & Special Reveal SVGs
    'coin_bronze': `<svg viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="#cd7f32" stroke="#5c3a1e" stroke-width="3"/><circle cx="50" cy="50" r="30" fill="none" stroke="#5c3a1e" stroke-width="2" stroke-dasharray="5,5"/></svg>`,
    'coin_silver': `<svg viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="#c0c0c0" stroke="#666" stroke-width="3"/><circle cx="50" cy="50" r="30" fill="none" stroke="#666" stroke-width="2" stroke-dasharray="5,5"/></svg>`,
    'coin_gold': `<svg viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="#ffd700" stroke="#b8860b" stroke-width="3"/><circle cx="50" cy="50" r="30" fill="none" stroke="#b8860b" stroke-width="2" stroke-dasharray="5,5"/></svg>`,
    'clover': `<svg viewBox="0 0 100 100"><path d="M50,50 Q30,20 50,10 Q70,20 50,50 Q80,30 90,50 Q80,70 50,50 Q70,80 50,90 Q30,80 50,50 Q20,70 10,50 Q20,30 50,50" fill="#2d6a4f" stroke="#d8f3dc" stroke-width="2"/></svg>`,
    'pot': `<svg viewBox="0 0 100 100"><path d="M20,40 Q20,85 50,90 Q80,85 80,40 L20,40" fill="#000"/><ellipse cx="50" cy="40" rx="30" ry="10" fill="#ffd700"/><text x="50" y="70" font-size="12" fill="white" text-anchor="middle">COLLECT</text></svg>`
};

/**
 * INITIALIZATION
 */
function init() {
    // Create Grid DOM
    for(let r=0; r<CONFIG.rows; r++) {
        state.grid[r] = [];
        state.goldenGrid[r] = [];
        for(let c=0; c<CONFIG.cols; c++) {
            let cell = document.createElement('div');
            cell.className = 'cell';
            cell.id = `cell-${r}-${c}`;
            gridEl.appendChild(cell);
            state.grid[r][c] = getRandomSymbol();
            state.goldenGrid[r][c] = false;
            renderSymbol(r, c, state.grid[r][c], false);
        }
    }
    updateUI();
}

/**
 * GAME LOOP & MECHANICS
 */

function getRandomSymbol() {
    let rand = Math.random();
    
    // Check Specials
    if (rand < CONFIG.specialWeights.fs) return 'fs';
    if (rand < CONFIG.specialWeights.fs + CONFIG.specialWeights.rainbow) return 'rainbow';

    // Weighted Standard Symbols
    let totalWeight = CONFIG.weights.reduce((a,b)=>a+b,0);
    let randomW = Math.random() * totalWeight;
    let weightSum = 0;
    
    for(let i=0; i<CONFIG.symbols.length; i++) {
        weightSum += CONFIG.weights[i];
        if(randomW <= weightSum) return CONFIG.symbols[i];
    }
    return CONFIG.symbols[0];
}

function renderSymbol(r, c, type, isFalling = false) {
    const cell = document.getElementById(`cell-${r}-${c}`);
    
    // Handle Golden Square Visual
    if(state.goldenGrid[r][c]) cell.classList.add('golden');
    else cell.classList.remove('golden');

    // Clear previous content
    cell.innerHTML = '';
    
    if(type === null) return; // Empty cell

    let div = document.createElement('div');
    div.className = 'symbol';
    if(isFalling) div.classList.add('falling');
    div.innerHTML = SVGS[type] || '';
    cell.appendChild(div);
}

async function spin() {
    if(state.isSpinning) return;
    
    if(!state.bonusActive && state.balance < state.bet) {
        alert("Insufficient Balance!");
        return;
    }

    state.isSpinning = true;
    state.currentWin = 0;
    state.fsTriggersInRound = 0;
    
    // Deduct bet if not in bonus
    if(!state.bonusActive) {
        state.balance -= state.bet;
        // Reset golden grid in base game
        resetGoldenGrid(); 
    } else {
        state.freeSpins--;
    }

    updateUI();
    updateControls();

    // Clear Grid Animation
    clearGridDOM();
    await wait(100);

    // Fill Grid Initially
    for(let c=0; c<CONFIG.cols; c++) {
        for(let r=0; r<CONFIG.rows; r++) {
            state.grid[r][c] = getRandomSymbol();
        }
    }
    renderFullGrid(true);
    await wait(500);

    // Evaluation Loop (Cascades)
    let keepCascading = true;
    while(keepCascading) {
        let winData = evaluateGrid(); // Check clusters
        
        if(winData.hasWin) {
            state.currentWin += winData.winAmount;
            
            // Mark Golden Squares
            winData.winningCells.forEach(pos => {
                state.goldenGrid[pos.r][pos.c] = true;
                // Highlight winning symbols
                let cell = document.getElementById(`cell-${pos.r}-${pos.c}`);
                if(cell.firstChild) cell.firstChild.classList.add('win-anim');
            });
            
            updateUI();
            await wait(600);

            // Remove Winning Symbols + Super Cascade (All of same type)
            let typesToRemove = [...winData.winningTypes];
            
            // Collect all cells to remove (Cluster + Same Type elsewhere)
            let removalSet = new Set();
            
            // First, add the winning cluster cells
            winData.winningCells.forEach(p => removalSet.add(`${p.r},${p.c}`));

            // Super Cascade: Find all other instances of winning types
            for(let r=0; r<CONFIG.rows; r++) {
                for(let c=0; c<CONFIG.cols; c++) {
                    if(typesToRemove.includes(state.grid[r][c])) {
                        removalSet.add(`${r},${c}`);
                        // Super cascade also creates golden squares
                        state.goldenGrid[r][c] = true; 
                    }
                }
            }

            // Visual Remove
            removalSet.forEach(key => {
                let [r,c] = key.split(',').map(Number);
                let cell = document.getElementById(`cell-${r}-${c}`);
                if(cell.firstChild) cell.firstChild.classList.add('removed');
                state.grid[r][c] = null; // Logic remove
            });

            await wait(300);
            renderFullGrid(false); // Update golden squares visual
            
            // Gravity & Refill
            await applyGravity();
            
        } else {
            keepCascading = false;
        }
    }

    // Check Rainbow Feature after cascades end
    if(hasRainbow()) {
        await activateRainbowFeature();
    }

    // Check Bonus Trigger (Accumulated FS symbols)
    // Note: FS symbols aren't removed by clusters usually, but if they stick we count them.
    // Simple logic: scan grid for FS symbols at end of round
    let fsCount = countSymbols('fs');
    if(fsCount >= 3) {
        await triggerBonus();
    }

    // Bonus Mode Logic
    if(state.bonusActive) {
        if(state.freeSpins <= 0) {
            endBonus();
        }
    }

    state.isSpinning = false;
    updateControls();
}

function evaluateGrid() {
    let visited = Array(CONFIG.rows).fill(0).map(() => Array(CONFIG.cols).fill(false));
    let totalRoundWin = 0;
    let winningTypes = new Set();
    let winningCells = []; // {r, c}

    // Helper for DFS
    function getCluster(r, c, type) {
        let stack = [[r,c]];
        let cluster = [];
        while(stack.length > 0) {
            let [cr, cc] = stack.pop();
            if(cr < 0 || cr >= CONFIG.rows || cc < 0 || cc >= CONFIG.cols) continue;
            if(visited[cr][cc]) continue;
            if(state.grid[cr][cc] !== type) continue;

            visited[cr][cc] = true;
            cluster.push({r: cr, c: cc});

            stack.push([cr+1, cc]);
            stack.push([cr-1, cc]);
            stack.push([cr, cc+1]);
            stack.push([cr, cc-1]);
        }
        return cluster;
    }

    let hasWin = false;

    for(let r=0; r<CONFIG.rows; r++) {
        for(let c=0; c<CONFIG.cols; c++) {
            if(!visited[r][c]) {
                let type = state.grid[r][c];
                // Ignore specials for cluster pays
                if(type && type !== 'fs' && type !== 'rainbow' && !type.startsWith('coin')) {
                    let cluster = getCluster(r, c, type);
                    if(cluster.length >= CONFIG.minCluster) {
                        hasWin = true;
                        winningTypes.add(type);
                        winningCells.push(...cluster);
                        // Calc win: Base * (ClusterSize - 4) * Bet
                        let symVal = CONFIG.paytable[type] || 0;
                        let win = symVal * (cluster.length - 4) * 0.5 * state.bet; // Simplified math
                        if(cluster.length > 10) win *= 1.5;
                        totalRoundWin += win;
                    }
                }
            }
        }
    }

    return { hasWin, winAmount: totalRoundWin, winningTypes, winningCells };
}

async function applyGravity() {
    // Move symbols down
    for(let c=0; c<CONFIG.cols; c++) {
        let writeRow = CONFIG.rows - 1;
        for(let r=CONFIG.rows - 1; r >= 0; r--) {
            if(state.grid[r][c] !== null) {
                state.grid[writeRow][c] = state.grid[r][c];
                if(writeRow !== r) state.grid[r][c] = null;
                writeRow--;
            }
        }
        // Fill top with new symbols
        for(let r=writeRow; r >= 0; r--) {
            state.grid[r][c] = getRandomSymbol();
        }
    }
    renderFullGrid(true); // Render with falling animation
    await wait(400);
}

function hasRainbow() {
    for(let r=0; r<CONFIG.rows; r++) {
        for(let c=0; c<CONFIG.cols; c++) {
            if(state.grid[r][c] === 'rainbow') return true;
        }
    }
    return false;
}

function countSymbols(type) {
    let count = 0;
    for(let r=0; r<CONFIG.rows; r++) {
        for(let c=0; c<CONFIG.cols; c++) {
            if(state.grid[r][c] === type) count++;
        }
    }
    return count;
}

/**
 * RAINBOW & GOLDEN SQUARE FEATURE
 */
async function activateRainbowFeature() {
    showMsg("RAINBOW ACTIVE", "");
    await wait(1000);
    hideMsg();

    // 1. Reveal Phase: Turn all Golden Squares into Coins/Specials
    let activeCells = [];
    for(let r=0; r<CONFIG.rows; r++) {
        for(let c=0; c<CONFIG.cols; c++) {
            if(state.goldenGrid[r][c]) {
                let reveal = getRainbowReveal();
                // Place object with value for calculation
                state.grid[r][c] = reveal; 
                activeCells.push({r,c, type: reveal.type, val: reveal.val});
                
                // Render Special Symbol
                renderSymbol(r, c, reveal.svgKey);
                // Add text overlay
                let cell = document.getElementById(`cell-${r}-${c}`);
                if(reveal.type === 'coin' || reveal.type === 'clover') {
                    let span = document.createElement('span');
                    span.className = 'coin-val';
                    span.innerText = reveal.type === 'clover' ? `x${reveal.val}` : `${reveal.val}x`;
                    cell.appendChild(span);
                }
            }
        }
    }
    await wait(800);

    // 2. Clover Logic (Multipliers) - Multiplies adjacent coins/pots
    // Need to process grid logic
    let totalRainbowWin = 0;
    
    // Process Clovers first
    activeCells.filter(x => x.type === 'clover').forEach(clover => {
        getNeighbors(clover.r, clover.c).forEach(n => {
            let target = activeCells.find(x => x.r === n.r && x.c === n.c);
            if(target && (target.type === 'coin' || target.type === 'pot')) {
                target.val *= clover.val;
                updateCellText(target.r, target.c, target.val);
            }
        });
    });
    await wait(500);

    // Process Pots (Collectors) - Collects adjacent coins/pots
    let pots = activeCells.filter(x => x.type === 'pot');
    // Simple logic: Pot sums adjacent, sets neighbors to 0? 
    // Standard mechanics: Pot collects value, keeps it. Neighbor stays? 
    // Usually Pot collects and clears neighbor. Let's sum adjacent coins.
    pots.forEach(pot => {
        let collected = 0;
        getNeighbors(pot.r, pot.c).forEach(n => {
            let target = activeCells.find(x => x.r === n.r && x.c === n.c);
            if(target && target.type === 'coin') {
                collected += target.val;
                // Visual: nullify coin? Let's keep it for show, but Pot gets value.
            }
        });
        pot.val += collected;
        // Update pot text (if we added one, which we didn't in render, add now)
        updateCellText(pot.r, pot.c, pot.val);
    });
    await wait(500);

    // 3. Calculate Total
    activeCells.forEach(cell => {
        if(cell.type === 'coin' || cell.type === 'pot') {
            totalRainbowWin += cell.val * state.bet;
        }
    });

    if(totalRainbowWin > 0) {
        state.currentWin += totalRainbowWin;
        updateUI();
        showMsg("FEATURE WIN", totalRainbowWin.toFixed(2));
        await wait(1500);
        hideMsg();
    }
}

function getRainbowReveal() {
    let r = Math.random();
    if(r < 0.65) {
        // Bronze Coin (0.2x - 4x)
        return { type: 'coin', svgKey: 'coin_bronze', val: (Math.random()*3.8 + 0.2).toFixed(1) };
    } else if (r < 0.85) {
        // Silver Coin (5x - 20x)
        return { type: 'coin', svgKey: 'coin_silver', val: Math.floor(Math.random()*15 + 5) };
    } else if (r < 0.92) {
        // Gold Coin (25x - 100x)
        return { type: 'coin', svgKey: 'coin_gold', val: Math.floor(Math.random()*75 + 25) };
    } else if (r < 0.97) {
        // Clover (2x - 10x)
        return { type: 'clover', svgKey: 'clover', val: Math.floor(Math.random()*8 + 2) };
    } else {
        // Pot
        return { type: 'pot', svgKey: 'pot', val: 0 }; // Starts at 0, collects
    }
}

function getNeighbors(r, c) {
    let n = [];
    if(r>0) n.push({r:r-1, c:c});
    if(r<CONFIG.rows-1) n.push({r:r+1, c:c});
    if(c>0) n.push({r:r, c:c-1});
    if(c<CONFIG.cols-1) n.push({r:r, c:c+1});
    return n;
}

function updateCellText(r, c, val) {
    let cell = document.getElementById(`cell-${r}-${c}`);
    let span = cell.querySelector('.coin-val');
    if(!span) {
        span = document.createElement('span');
        span.className = 'coin-val';
        cell.appendChild(span);
    }
    span.innerText = parseFloat(val).toFixed(1) + 'x';
}

/**
 * BONUS & BUY FEATURE
 */
async function triggerBonus() {
    showMsg("BONUS TRIGGERED!", "8 FREE SPINS");
    await wait(2000);
    hideMsg();
    
    state.bonusActive = true;
    state.freeSpins += 8;
    bonusBanner.style.display = 'block';
    updateUI();
}

function endBonus() {
    state.bonusActive = false;
    bonusBanner.style.display = 'none';
    resetGoldenGrid();
    renderFullGrid(false);
    showMsg("BONUS COMPLETED", `Total: ${state.currentWin.toFixed(2)}`);
    setTimeout(hideMsg, 2000);
}

function buyBonus() {
    let cost = state.bet * 100;
    if(state.balance >= cost) {
        state.balance -= cost;
        state.bonusActive = true;
        state.freeSpins = 8;
        
        // Force UI update
        updateUI();
        bonusBanner.style.display = 'block';
        
        // Trigger Start
        showMsg("BONUS BOUGHT", "Good Luck!");
        setTimeout(() => {
            hideMsg();
            spin();
        }, 1500);
    } else {
        alert("Not enough balance!");
    }
}

/**
 * HELPERS & UI
 */
function renderFullGrid(animate = false) {
    for(let r=0; r<CONFIG.rows; r++) {
        for(let c=0; c<CONFIG.cols; c++) {
            renderSymbol(r, c, state.grid[r][c], animate);
        }
    }
}

function clearGridDOM() {
    let cells = document.querySelectorAll('.symbol');
    cells.forEach(el => el.remove());
}

function resetGoldenGrid() {
    for(let r=0; r<CONFIG.rows; r++) {
        for(let c=0; c<CONFIG.cols; c++) state.goldenGrid[r][c] = false;
    }
}

function changeBet(delta) {
    if(state.isSpinning) return;
    let newBet = state.bet + delta;
    if(newBet >= 1 && newBet <= 100) state.bet = newBet;
    updateUI();
}

function updateUI() {
    balEl.innerText = state.balance.toFixed(2);
    winEl.innerText = state.currentWin.toFixed(2);
    betEl.innerText = state.bet;
    fsCountEl.innerText = state.freeSpins;
}

function updateControls() {
    spinBtn.disabled = state.isSpinning;
    buyBtn.disabled = state.isSpinning || state.bonusActive;
    document.querySelectorAll('.bet-btn').forEach(b => b.disabled = state.isSpinning);
}

function showMsg(title, val) {
    msgTitle.innerText = title;
    msgVal.innerText = val;
    msgOverlay.style.display = 'block';
}

function hideMsg() {
    msgOverlay.style.display = 'none';
}

const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// Start
init();

</script>
</body>
</html>